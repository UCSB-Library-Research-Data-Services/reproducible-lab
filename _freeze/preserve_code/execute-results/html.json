{
  "hash": "9b61ac9a77a1903e57d19bda826c01a5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Preserve your code\"\n---\n\n## Making your code readable\n\n\n::: {.cell}\n::: {.cell-output-display}\n![https://twitter.com/cjm4189/status/1557346489613094914](img/code_handover.png){width=380}\n:::\n:::\n\n\n\nIt is important to make your code easy to read if you hope that others will reuse it. It starts with using a **consistent style** witing your scripts (at least within a project). \n\n- Here is a good style guide for R: <https://style.tidyverse.org/>\n- Style guide for Python: <https://www.python.org/dev/peps/pep-0008/>\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport this\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n```\n\n\n:::\n:::\n\n\nThere is also the **visual aspect** of the code that should not be neglected. Like prose, if you receive a long text without any paragraphs, you might be not very excited about reading it. _Indentation_, _spaces_, and _empty lines_ should be leveraged to make a script visually inviting and easy to read. The good news is that most Integrated Development Environments (IDEs) will help you to do so by auto formatting your scripts according to conventions.  Note that also a lot of IDEs, such as RStudio, rely on some conventions to ease the navigation of scripts and notebooks. For example, _try to add four `-` or `#` after a line starting with one or several `#` in an R Script!_\n\n\n## Comments\n\n***Real Programmers don't comment their code. If it was hard to write, it should be hard to understand.*** \\\nTom Van Vleck, based on people he knew..._ (<https://multicians.org/thvv/realprogs.html>)\n\nJoke aside, it is really hard to comment too much your code, because even steps that might seem trivial today might not be so anymore in a few weeks or months for now. In addition, well commented code is more likely to be read by others. Note also that **comments should complement the code** and should not being seen as work around vague naming conventions of variables or functions, but neither should they simple restate what the code is doing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 9.81  #  gravitational acceleration               POOR\ngravity_acc <- 9.81  #  gravitational acceleration     BETTER\n\nname_index <- 0  # set name_index to 0                 POOR\nname_index <- 0                                        BETTER\n```\n:::\n\n\n\n### Header\n\nIt is good to add a header to your script that will provide basic information such as:\n\n- Purpose of the script (Long title style)\n- Who are the authors\n- A contact email \n- How to run, if the code is a program\n\nOptional:\n\n- A longer description about the script purpose\n- A starting date and potentially last updated one, although this information becomes redundant with repository information\n\nNote that R Studio does something similar by default when creating a new R Markdown document!\n\n### Inline \n\nIt does not matter if you are using a script or notebook. It is important to provide comments along your code to complement it by:\n\n- Explaining what the code does\n- Capturing decisions that were made on the analytical side. For example, why a specific value was used for a threshold.\n- Specifying why and when code was added to handle an edge case such as an unexpected value in the data (so a new user doesn't have to guess what the code does and might want to delete it assuming it is not necessary)\n\nOther thoughts:\n\n- It is OK to state (what seems) the obvious (some might disagree with this statement)\n- Try to keep comments to the point and short\n\n\n\n### Functions\n\nBoth Python and R have conventions on how to document functions. Adopting those conventions will help you to make your code readable but also to automate part of the documentation development.\n\n#### Roxygen2\n\nThe goal of roxygen2 is to make documenting your code as easy as possible. It can dynamically inspect the objects that it’s documenting, so it can automatically add data that you’d otherwise have to write by hand.\n\nHow do we insert it? Make sure you cursor is inside the function you want to document and from RStudio Menu _Code -> Insert Roxygen Skeleton_\n\nExample:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Add together two numbers\n#'\n#' @param x A number\n#' @param y A number\n#' @return The sum of \\code{x} and \\code{y}\n#' @examples\n#' add(1, 1)\n#' add(10, 1)\nadd2 <- function(x, y) {\n  x + y\n}\n```\n:::\n\n\nTry it! \n- Copy the function (without the documentation) in a new script \n- Add a third parameter to the function such as it sums 3 numbers\n- Add the Roxygen skeleton\n- Fill it to best describe your function\n\nNote that when you are developing an R package, the Roxygen skeleton can be leveraged to develop the help pages of your package so you only have one place to update and the help will synchronize automatically.\n\n#### Python Docstring\n\nA docstring is a string literal that occurs as the first statement in a module,  function, class, or method definition. Such a docstring becomes the `__doc__` special attribute of that object.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef complex(real=0.0, imag=0.0):\n    \"\"\"Form a complex number.\n\n    Keyword arguments:\n    real -- the real part (default 0.0)\n    imag -- the imaginary part (default 0.0)\n    \"\"\"\n    if imag == 0.0 and real == 0.0:\n        return complex_zero\n```\n:::\n\n\nGo here for more information: <https://www.python.org/dev/peps/pep-0257/>\n\n\n## Leveraging Notebooks\n\nWe have focused on and been experimenting with Notebooks during the week because they provide space to further develop content, such as methodology, around the code you are developing in your analysis. Notebooks also enable you to integrate the outputs of your scientific research with the code that was used to produce it. Finally, notebooks can be rendered into various formats that allows them to be shared with a broad audience.\n\nNotebooks are not only used within the scientific community, see [here](https://peerj.com/preprints/3182.pdf) for some thoughts from Airbnb data science team.\n\n\n---\n\n## Hands-on\n\n### Documenting\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetPercent <- function( value, pct ) {\n    result <- value * ( pct / 100 )\n    return( result )\n}\n```\n:::\n\n\nTry adding the Roxygen Skeleton to this function and fill all the information you think is necessary to document the function\n\n### Commenting\n\nLet's try to improve the readability and documentation of this repository: <https://github.com/brunj7/better-comments>. Follow the instructions on the README\n\nFor inspiration, you can check out the NASA code for APOLLO 11 dating from 1969: <https://github.com/chrislgarry/Apollo-11>!!\n\n---\n\n\n## Code repositories\n\nOn-line code repositories are a great way to version and share your code. Here are a few examples of git-based code repositories:\n\n- GitHub\n- GitLab\n- Bitbucket\n- SourceForge\n\nNote however that there is no long-term commitment of any of those main code repositories and that archiving the specific snapshot of your code that was used for a specific analysis along your data is a great idea. Several data repositories offer an integration that lets you do that with data repositories. For example, Zenodo has a great integration with GitHub that lets you issue a DOI for a specific release (read snapshot) of your repository and preserve it independently from the code repository. See [here](https://github.com/OpenScienceMOOC/Module-5-Open-Research-Software-and-Open-Source/blob/master/content_development/Task_2.md) for more details.\n\nNote that code repositories and data repositories complement each other: you can see your code repository as the live version of your work and the code snapshot archive as the historical trace that was produced for a specific analysis. In other words, we recommend linking both the code repository and its snapshot to the data archive.\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}