{
  "hash": "0cb1066d879e7a18578ae369138293e2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Using git at the command line\"\nexecute: \n  eval: FALSE\nengine: knitr\n---\n\n\n## Setup your git profile\n\n### your git identity\n\nIf you are not sure if you have already set your git identity, you can check this running this command:\n\n```bash\ngit config --global --list\n```\n\nIf you identity is not set yet, you need to provide your name and email (we recommend to use the same email as used when setting your GitHub account): \n\n```bash\ngit config --global user.name \"your Full Name\"\ngit config --global user.email \"your Email\"\n```\n\n\n##### Optional\n\nCheck that everything is correct: \n\n```bash\ngit config --global --list\n```\n\nModify everything at the same time:\n\n```bash\ngit config --global --edit\n```\n\nSet your text editor: \n\n```bash\ngit config --system core.editor nano\n```\n\nHere [`nano`](https://www.nano-editor.org) is used as example; you can choose most of the text editor you might have installed on your computer (atom, sublime, notepad++ ...).\n\nProblem with any of those steps? Check out Jenny Brian [Happy git trouble shooting section](http://happygitwithr.com/troubleshooting.html){target=\"_blank\"}\n\n\n## GitHub credentials\n\nNormally if you have already used GitHub tokens your Operating System (Windows, MacOSX, ...) should have cached the necessary credentials to log in to your GitHub account (necessary to be able to push (write) content to the remote repository).\n\n### Setting up your GitHub Token\n\nYou can find the latest guidelines on how to setup your personal GitHub token **[here](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic)**\n\n1. Choose a token name that is related to the machine you are using (not requires, but a good idea :) )\n\n2. Set the expiration date to `90 days`\n\n3. We recommend to select the following options:\n\n   - all repo actions\n   - workflow\n   - gist\n   - all user actions\n\n   ![](img/github-token.png){width=\"65%\"}\n\n4. Then click the `Generate token` button at the bottom of the page.\n\n**DO NOT CLOSE the next page** as it will be the only time you can see your token.\n\nCopy your token to your clipboard and then push to GitHub from the command line using `git push`. When you are prompted for your password, copy your token.\n\nOnly once it has worked and that your token as been cached by your OS password manager you can close the GitHub webpage displaying your token value.\n\n### Setting up your SSH key\n\nAnother option is to set up the method that is commonly used by many different services to authenticate access on the command line.  This method is called Secure Shell Protocol (SSH).  SSH is a cryptographic network protocol that allows secure communication between computers using an otherwise insecure network.\n\nSSH uses what is called a key pair. This is **two** keys that work together to validate access. One key is publicly known and called the **public key**, and the other key called the **private key** is kept private. Very descriptive names.\n\nYou can think of the public key as a padlock, and only you have the key (the private key) to open it. You use the public key where you want a secure method of communication, such as your GitHub account.  You give this padlock, or public key, to GitHub and say \"lock the communications to my account with this so that only computers that have my private key can unlock communications and send git commands as my GitHub account.\"\n\nThe first thing we are going to do is check if this has already been done on the computer you're on.  Because generally speaking, this setup only needs to happen once and then you can forget about it:\n\n```bash\nls -al ~/.ssh\n```\n\nYour output is going to look a little different depending on whether or not SSH has ever been set up on the computer you are using.\n\n\n#### Already set up: \n\nIf SSH has been set up on the computer you're using, the public and private key pairs will be listed. The file names are either `id_ed25519`/`id_ed25519.pub` or `id_rsa`/`id_rsa.pub` depending on how the key pairs were set up.  \n\n#### Not Set up:\n\n```bash\nls: cannot access '/Users/brunj7/.ssh': No such file or directory\n```\n\nCreate an SSH key pair\n\nTo create an SSH key pair Vlad uses this command, where the `-t` option specifies which type of algorithm to use and `-C` attaches a comment to the key (here, Vlad's email):\n\n```bash\n$ ssh-keygen -t ed25519 -C \"youremail@provider.org\"\n```\n\nIf you are using a legacy system that doesn't support the Ed25519 algorithm, use:\n\n`$ ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"`\n\n```\nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/Users/brunj7/.ssh/id_ed25519):\n```\n\nWe want to use the default file, so just press <kbd>Enter</kbd>.\n\n```output\nCreated directory '/Users/brunj7/.ssh'.\nEnter passphrase (empty for no passphrase):\n```\n\nNow, it is prompting you for a passphrase. Be sure to use something memorable or save your passphrase somewhere, as there is no \"reset my password\" option.\n\n:::{.callout-warning}\nWhen you enter password at the shell, the keystrokes do not produce the usual \"dot\" showing you that you are typing, but your keystrokes are being registered... so keep typing you password !!\n:::\n\n```\nEnter same passphrase again:\n```\n\nAfter entering the same passphrase a second time, we receive the confirmation\n\n```\nYour identification has been saved in /Users/brunj7/.ssh/id_ed25519\nYour public key has been saved in /Users/brunj7/.ssh/id_ed25519.pub\nThe key fingerprint is:\nSHA256:SMSPIStNyA00KPxuYu94KpZgRAYjgt9g4BA4kFy3g1o vlad@tran.sylvan.ia\nThe key's randomart image is:\n+--[ED25519 256]--+\n|^B== o.          |\n|%*=.*.+          |\n|+=.E =.+         |\n| .=.+.o..        |\n|....  . S        |\n|.+ o             |\n|+ =              |\n|.o.o             |\n|oo+.             |\n+----[SHA256]-----+\n```\n\nThe \"identification\" is actually the private key. You should never share it.  The public key is appropriately named.  The \"key fingerprint\" is a shorter version of a public key.\n\nNow that we have generated the SSH keys, we will find the SSH files when we check.\n\n```bash\nls -al ~/.ssh\n```\n\n```bash\ndrwxr-xr-x 1 brunj7  staff 197121  Oct 23  13:14 ./\ndrwxr-xr-x 1 brunj7  staff 197121  Mar 11  09:21 ../\n-rw------- 1 brunj7  staff    464  Apr 21  2023 id_ed25519\n-rw-r--r-- 1 brunj7  staff    103  Apr 21  2023 id_ed25519.pub\n```\n\n## Clone a repository\n\n::: {.callout-tip}\nIf you not have yet your `favorite-desserts` GitHub repository, please follow those [steps](https://ucsb-library-research-data-services.github.io/reproducible-lab/01-handson_github_website.html)\n:::\n\n\nNavigate to the folder (e.g `cd ~/Documents`) where you want to save your repository and run the following command: \n\n```bash\ngit clone https://github.com/brunj7/favorite-desserts.git\n```\n\nYou should have a new folder on your local machine named favorite-desserts after your repository :\n\n```bash\nls\n```\n\nGo inside the repository:\n\n```bash\ncd favorite-desserts\nls -al\n```\n\nThis should return the exact same content that is currently on GitHub!\n\n\n## Tracking your work\n\nLet's create a text file called `index.md` and add it to our repository. The file will later be converted into a webpage by GitHub pages. We'll write the file using a syntax called Markdown, which is why we use the `.md` extensions. \n\n:::{.callout-note}\n## Note\n\nWe'll use `nano` to edit the file; you can use whatever editor you like. In particular, this does not have to be the `core.editor` you set globally earlier. But remember, the bash command to create or edit a new file will depend on the editor you choose (it might not be `nano`). For a refresher on text editors, check out [\"Which Editor?\"](https://swcarpentry.github.io/shell-novice/03-create.html#which-editor) in [The Unix Shell](https://swcarpentry.github.io/shell-novice/) lesson.\n:::\n\n```bash\nnano index.md\n```\n\nType the text below, replacing the names with people you know:\n\n```\n## Listing of my favorite desserts\n\n- Julien, crepes\n\n```\n\nExit nano and save your changes.\n\nCheck it worked:\n\n```bash\n$ cat index.md\n```\n\nYou should see the content you just typed!\n\n\nIf we check the status of our project again,\nGit tells us that it's noticed the new file:\n\n```bash\n$ git status\n```\n\n```output\nOn branch main\n\nNo commits yet\n\nUntracked files:\n   (use \"git add <file>...\" to include in what will be committed)\n\n\tindex.md\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n\nThe \"untracked files\" message means that there's a file in the directory\nthat Git isn't keeping track of.\nWe can tell Git to track a file using `git add`:\n\n```bash\n$ git add index.md\n```\n\nand then check that the right thing happened:\n\n```bash\n$ git status\n```\n\n```output\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n\n\tnew file:   index.md\n\n```\n\nGit now knows that it's supposed to keep track of `index.md`,\nbut it hasn't recorded these changes as a commit yet.\nTo get it to do that,\nwe need to run one more command:\n\n```bash\n$ git commit -m \"start new webpage\"\n```\n\n```output\n[main (root-commit) f22b25e] Start new webpage\n 1 file changed, 1 insertion(+)\n create mode 100644 index.md\n```\n\nWhen we run `git commit`,\nGit takes everything we have told it to save by using `git add` and stores a copy permanently inside the special `.git` directory.\nThis permanent copy is called a commit (revision) and its short identifier is `f22b25e`. Your commit may have another identifier.\n\nWe use the `-m` flag (for \"message\") to record a short, descriptive, and specific comment that will help us remember later on what we did and why. If we just run `git commit` without the `-m` option, Git will launch `nano` (or whatever other editor we configured as `core.editor`) so that we can write a longer message.\n\nGood commit messages start with a brief (\\<50 characters) statement about the changes made in the commit. Generally, the message should complete the sentence \"If applied, this commit will\" <commit message here>. If you want to go into more detail, add a blank line between the summary line and your additional notes. Use this additional space to explain why you made changes and/or what their impact will be.\n\nIf we run `git status` now:\n\n```bash\n$ git status\n```\n\n```output\nOn branch main\nnothing to commit, working tree clean\n```\n\nit tells us everything is up to date.\nIf we want to know what we've done recently,\nwe can ask Git to show us the project's history using `git log`:\n\n```bash\n$ git log\n```\n\n```output\ncommit f22b25e3233b4645dabd0d81e651fe074bd8e73b\nAuthor: ...\nDate:   Thu Aug 22 09:51:46 2013 -0400\n\n    start new webpage\n```\n\n`git log` lists all commits  made to a repository in reverse chronological order.\nThe listing for each commit includes\nthe commit's full identifier\n(which starts with the same characters as\nthe short identifier printed by the `git commit` command earlier),\nthe commit's author,\nwhen it was created,\nand the log message Git was given when the commit was created.\n\n:::{.callout-note}\n## Where Are My Changes?\n\nIf we run `ls` at this point, we will still see just one file called `index.md`.\nThat's because Git saves information about files' history\nin the special `.git` directory mentioned earlier\nso that our filesystem doesn't become cluttered\n(and so that we can't accidentally edit or delete an old version).\n:::\n\n\nLet's adds more information to the file.\n(Again, we'll edit with `nano` and then `cat` the file to show its contents;\nyou may use a different editor, and don't need to `cat`.)\n\n```bash\n$ nano index.md\n```\n\n```output\n## Listing of my favorite desserts\n\n- Julien, crepes\n- Sophia, chocolate\n\n```\n\nWhen we run `git status` now,\nit tells us that a file it already knows about has been modified:\n\n```bash\n$ git status\n```\n\n```output\nOn branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   index.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nThe last line is the key phrase:\n\"no changes added to commit\". \n\nWe have changed this file, but we haven't told Git we will want to save those changes (which we do with `git add`) nor have we saved them (which we do with `git commit`). So let's do that now. It is good practice to always review our changes before saving them. We do this using `git diff`.\n\nThis shows us the differences between the current state of the file and the most recently saved version:\n\n```bash\n$ git diff\n```\n\n```output\ndiff --git a/index.md b/index.md\nindex 7d781a7..bbb33fe 100644\n--- a/index.md\n+++ b/index.md\n@@ -1 +1,3 @@\n## Listing of my favorite desserts\n\n- Julien, crepes\n+ - Sophia, chocolate\n\n```\n\nThe output is cryptic because\nit is actually a series of commands for tools like editors and `patch` telling them how to reconstruct one file given the other.\nIf we break it down into pieces:\n\n1. The first line tells us that Git is producing output similar to the Unix `diff` command\n  comparing the old and new versions of the file.\n2. The second line tells exactly which versions of the file\n  Git is comparing;\n  `7d781a7` and `bbb33fe` are unique computer-generated labels for those versions.\n3. The third and fourth lines once again show the name of the file being changed.\n4. The remaining lines are the most interesting, they show us the actual differences\n  and the lines on which they occur.\n  In particular,\n  the `+` marker in the first column shows where we added a line.\n\nAfter reviewing our change, it's time to commit it:\n\n```bash\n$ git commit -m \"add Sophia\"\n```\n\n```output\nOn branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   index.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nWhoops:\nGit won't commit because we didn't use `git add` first.\nLet's fix that:\n\n```bash\n$ git add index.md\n$ git commit -m \"add Sophia\"\n```\n\n```output\n[main 019f377] add Sophia\n 1 file changed, 1 insertions(+)\n```\n\n:::{.callout-note}\nGit insists that we add files to the set we want to commit before actually committing anything. This allows us to commit our\nchanges in stages and capture changes in logical portions rather than only large batches.\nFor example, suppose we're adding a few citations to relevant research to our thesis.\nWe might want to commit those additions, and the corresponding bibliography entries,\nbut *not* commit some of our work drafting the conclusion (which we haven't finished yet).\n\nTo allow for this, Git has a special *staging area* where it keeps track of things that have been added to\nthe current changeset but not yet committed.\n:::\n\n## Exploring git history\n\nYou can look at the history of what we've done so far:\n\n```bash\n$ git log\n```\n\nIt should look something like this:\n\n```output\ncommit d11d7e52ab98d3d4c18cde4c4a0bbeea3fe40983 (HEAD -> main)\nAuthor: ...\nDate:   Thu Oct 19 12:07:51 2023 -0400\n\n    add Sophia\n\ncommit 019f37773f9f18b77f508990df65e56a34df45de\nAuthor: ...\nDate:   Thu Oct 19 12:03:04 2023 -0400\n\n    start new webpage\n\ncommit 8defaab26aa641a4233896ec68e603c541aa77b4\nAuthor: ...\nDate:   Thu Oct 19 12:01:17 2023 -0400\n\n    intial commit\n```\n\n### Paging the Log\n\nWhen the output of `git log` is too long to fit in your screen, `git` uses a program to split it into pages of the size of your screen.\nWhen this \"pager\" is called, you will notice that the last line in your screen is a `:`, instead of your usual prompt.\n\n- To get out of the pager, press <kbd>Q</kbd>.\n- To move to the next page, press <kbd>Spacebar</kbd>.\n- To search for `some_word` in all pages,\n  press <kbd>/</kbd>\n  and type `some_word`.\n  Navigate through matches pressing <kbd>N</kbd>.\n\n\nTo avoid having `git log` cover your entire terminal screen, you can limit the\nnumber of commits that Git lists by using `-N`, where `N` is the number of\ncommits that you want to view. For example, if you only want information from\nthe last commit you can use:\n\n```bash\n$ git log -1\n```\n\n```output\ncommit d11d7e52ab98d3d4c18cde4c4a0bbeea3fe40983 (HEAD -> main)\nAuthor: ...\nDate:   Thu Oct 19 12:07:51 2023 -0400\n\n    add Sophia\n```\n\nYou can also reduce the quantity of information using the\n`--oneline` option:\n\n```bash\n$ git log --oneline\n```\n\n```output\nd11d7e5 (HEAD -> main) add Sophia\n019f377 start new webpage\n8defaab initial commit\n```\n\nYou can also combine the `--oneline` option with others. One useful\ncombination adds `--graph` to display the commit history as a text-based\ngraph and to indicate which commits are associated with the\ncurrent `HEAD`, the current branch `main`, or\n[other Git references][git-references]:\n\n```bash\n$ git log --oneline --graph\n```\n\n```output\n* d11d7e5 (HEAD -> main) add Sophia\n* 019f377 start new webpage\n* 8defaab initial commit\n```\n\n## Sending changes back to GitHub\n\nNow that we have created these two commits on our local machine, our local version of the repository is different from the version on GitHub. You can see this when running `git status` at the beginning of the message you should have  \"Your branch is ahead of 'origin/master' by two commits\". This can be translated as you have two additional commits on your local machine that you never shared back to the remote repository on GitHub. Open your favorite web browser and look at the content of your repository on GitHub. You will see there is no `index.md` file on GitHub.\n\n\nThere are two git commands to exchange between local and remote versions of a repository:\n\n- `pull`: git will get the latest remote (GitHub in our case) version and try to merge it with your local version\n- `push`: git will send your local version to the remote version of the repository \n\nBefore sending your local version to the remote, you should always get the latest remote version first. In other words, **you should pull first and push second**. This is the way git protects the remote version against incompatibilities with the local version. You always deal with potential problems on your local machine. Therefore your sequence will always be:\n\n1. `pull`\n2. `push`\n\nLet's do it:\n\n```bash\ngit pull\n```\n\nNormally nothing should have changed on the remote\n\nNow we can push our changes to GitHub:\n\n```bash\ngit push\n```\n\nRefresh the repository webpage, you should now see the `index.md` file!\n\n\n## Aknowledgements\n\nThis section is adapted from Seth Erickson's version of the Software Carpentry [introduction to git](https://ucsbcarpentry.github.io/git-novice/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}